{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Kosh is short for Vidya Kosh (Treasury of Knowledge).</p> <p>This repository is a collection of android Kotlin + Compose knowledge to revise, keep in touch with imp topics</p>"},{"location":"#welcome","title":"Welcome","text":"<p>Explore the topics in the navigation menu.</p>"},{"location":"Managing-State/","title":"Managing State","text":"<p>In Jetpack Compose, managing state is about deciding how long a piece of information should \"live.\"</p>"},{"location":"Managing-State/#remember-vs-remembersaveable","title":"remember vs rememberSaveable","text":"Feature <code>remember</code> <code>rememberSaveable</code> Survival Survives Recomposition. Survives Recomposition + Screen Rotation + Process Death. Storage In-memory (RAM). Bundle (saved on disk/system memory). Data Types Anything (Objects, Lambdas, etc.). Only \"Saveable\" types (Primitives, Parcelable, Serializable). Best For Transient UI state (e.g., is a dropdown open). User-entered data (e.g., text in a form)."},{"location":"Managing-State/#how-they-work-internally-easy-version","title":"How They Work Internally (Easy Version)","text":""},{"location":"Managing-State/#1-remember-the-slot-table","title":"1. <code>remember</code>: The Slot Table","text":"<p>Think of <code>remember</code> as a sticky note on a specific part of your UI tree.</p> <ul> <li>The Mechanism: Compose maintains a \"Slot Table\" (a flat data structure that stores the state of your UI).</li> <li>The Process: When a Composable runs for the first time, <code>remember</code> calculates the value and stores it in a \"slot.\"   During the next recomposition, Compose looks at that same slot and says, \"Oh, I already have a value for this,\" and   skips the calculation.</li> <li>The Limit: If the Activity is destroyed (like when you rotate the screen), the entire Slot Table is cleared. Your   sticky note is gone.</li> </ul>"},{"location":"Managing-State/#2-remembersaveable-the-registry-bundle","title":"2. <code>rememberSaveable</code>: The Registry &amp; Bundle","text":"<p>Think of <code>rememberSaveable</code> as a note kept in a drawer (the Android OS).</p> <ul> <li>The Mechanism: It uses <code>remember</code> internally to stay fast during recomposition, but it adds a second layer called   the <code>SaveableStateRegistry</code>.</li> <li>The Process: When the system is about to destroy your Activity (rotation or memory pressure), <code>rememberSaveable</code>   takes your value, converts it into a <code>Bundle</code> (a format Android understands), and hands it to the OS.</li> <li>The Restoration: When the Activity is recreated, Compose asks the OS, \"Do you have any saved values for this ID?\"   It then pulls the value back out of the drawer and restores it to the UI.</li> </ul> <p>Understanding state in Jetpack Compose This video explains the fundamental concepts of state management in Compose, including when and why to use different state-saving APIs.</p> <p>When you want to use <code>rememberSaveable</code> with a custom data class, Android doesn't automatically know how to save it because the system can only store simple types (like Strings or Ints) in its \"storage drawer\" (the Bundle).</p> <p>To fix this, you create a Saver to \"break down\" your object and then \"rebuild\" it later.</p>"},{"location":"Managing-State/#1-the-data-class","title":"1. The Data Class","text":"<p>Imagine you have a simple class that isn't automatically saveable:</p> <pre><code>data class Person(val name: String, val age: Int)\n</code></pre>"},{"location":"Managing-State/#2-the-custom-saver","title":"2. The Custom Saver","text":"<p>You define a <code>Saver</code> object that tells Compose two things: how to Save (convert the object to a list or map) and how to Restore (take that list/map and make a <code>Person</code> again).</p> <pre><code>val PersonSaver = Saver&lt;Person, Map&lt;String, Any&gt;&gt;(\n    save = { mapOf(\"name\" to it.name, \"age\" to it.age) }, // How to pack it\n    restore = { Person(it[\"name\"] as String, it[\"age\"] as Int) } // How to unpack it\n)\n</code></pre>"},{"location":"Managing-State/#3-how-to-use-it-in-ui","title":"3. How to use it in UI","text":"<p>Pass your custom saver into the <code>stateSaver</code> parameter of <code>rememberSaveable</code>:</p> <pre><code>@Composable\nfun PersonProfile() {\n    var person by rememberSaveable(stateSaver = PersonSaver) {\n        mutableStateOf(Person(\"John\", 25))\n    }\n\n    // Now if you rotate the screen, 'person' will stay updated! [00:03:38]\n}\n</code></pre>"},{"location":"Managing-State/#why-do-this","title":"Why do this?","text":"<ul> <li>**Standard <code>rememberSaveable**</code> would crash if you tried to pass it a <code>Person</code> object directly because it's not a   primitive type [02:11].</li> <li>The Saver acts as a bridge, converting your complex object into a format the Android Bundle can   handle [02:46].</li> </ul> <p>Watch: Creating a Custom Saver in Jetpack Compose</p>"},{"location":"Navigation/","title":"Navigation","text":"<p>In November 2025, Google officially released Navigation 3 (Nav3) as a stable library. It is a fundamental shift from the \"current\" Navigation Compose (Nav2) you are likely using.</p> <p>The main difference is that Nav2 treats navigation as a \"black box\" where the library owns the state, while Nav3 treats navigation as a State-first list that you own.</p>"},{"location":"Navigation/#1-the-philosophical-difference","title":"1. The Philosophical Difference","text":"Feature Navigation Compose (Current/Nav2) Navigation 3 (New/Nav3) Ownership The library owns the backstack (via <code>NavController</code>). You own the backstack (as a <code>SnapshotStateList</code>). Routing String-based or Type-safe routes. Keys-based. A screen is just a key in a list. UI Component <code>NavHost</code> <code>NavDisplay</code> Philosophy Command-based (<code>navController.navigate()</code>). Declarative. You add an item to a list, and the UI reacts."},{"location":"Navigation/#2-deep-dive-key-technical-differences","title":"2. Deep Dive: Key Technical Differences","text":""},{"location":"Navigation/#a-the-backstack-is-just-a-list","title":"A. The Backstack is just a <code>List</code>","text":"<p>In the current library, you can\u2019t easily see or modify the entire backstack without hacks. In Nav3, the backstack is literally just a list of \"keys\" (serializable classes).</p> <ul> <li>Nav2: You call <code>Maps(\"details\")</code> and trust the library to add it to its internal hidden stack.</li> <li>Nav3: You have a <code>mutableStateListOf(HomeKey, DetailsKey)</code>. To go back, you simply call <code>list.removeLast()</code>.</li> </ul>"},{"location":"Navigation/#b-the-speed-limit-tech-for-devs-adaptive-layouts","title":"B. The \"Speed Limit\" Tech for Devs: Adaptive Layouts","text":"<p>One of the biggest pain points in the current library is List-Detail views (showing two screens side-by-side on a tablet).</p> <ul> <li>Current: You often have to manage two separate <code>NavControllers</code> or manually swap composables.</li> <li>Nav3: It introduces Scenes. A <code>NavDisplay</code> can use a <code>TwoPaneSceneStrategy</code>. It looks at your list, sees two   keys, and decides to show them side-by-side automatically because the screen is wide enough.</li> </ul>"},{"location":"Navigation/#c-handling-the-speed-limit-road-sign-analogy","title":"C. Handling the Speed Limit (Road Sign Analogy)","text":"<p>In your previous question, you liked the \"one-button\" sync in the Lexus. Nav3 has a similar concept for state:</p> <ul> <li>In the current library, if you rotate the screen or the process dies, the <code>NavController</code> tries to \"reconstruct\" the   state from its internal logic.</li> <li>In Nav3, because the state is just a list in your <code>ViewModel</code> or <code>SavedStateHandle</code>, it is \"Transparent.\"There   is no guessing; the UI is always a direct reflection of your data.</li> </ul>"},{"location":"Navigation/#3-comparison-of-code","title":"3. Comparison of Code","text":"<p>Current Navigation (Nav2):</p> <pre><code>// You define a graph and the library manages the stack\nNavHost(navController, startDestination = \"home\") {\n    composable(\"home\") { HomeScreen(onNavigate = { navController.navigate(\"details\") }) }\n    composable(\"details\") { DetailsScreen() }\n}\n</code></pre> <p>Navigation 3 (Nav3):</p> <pre><code>// You own the list of screens\nval backStack = rememberNavBackStack(HomeKey)\n\nNavDisplay(\n    backStack = backStack,\n    entryProvider = entryProvider {\n        entry&lt;HomeKey&gt; { HomeScreen(onNavigate = { backStack.add(DetailsKey) }) }\n        entry&lt;DetailsKey&gt; { DetailsScreen() }\n    }\n)\n</code></pre>"}]}